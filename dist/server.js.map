{"version":3,"sources":["../src/server.ts","../src/config/db.ts","../src/middlewares/error-handler.ts","../src/routes/user.route.ts","../src/models/user.model.ts","../src/services/user.service.ts","../src/controllers/user.controller.ts","../src/routes/auth.route.ts","../src/services/auth.service.ts","../src/controllers/auth.controller.ts","../src/middlewares/jwt-verification.ts"],"sourcesContent":["import express, { Request, Response } from \"express\";\nimport dotenv from \"dotenv\";\nimport morgan from \"morgan\";\nimport cookieParser from \"cookie-parser\";\nimport { connectToDB } from \"./config/db\";\nimport { globalErrorHandler } from \"./middlewares/error-handler\";\nimport userRouter from \"./routes/user.route\";\nimport authRouter from \"./routes/auth.route\";\ndotenv.config();\n// .......................\n\nconst PORT = process.env.PORT || 7000;\n\nconst startServer = async () => {\n  try {\n    await connectToDB();\n\n    const app = express();\n\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(morgan(\"dev\"));\n    app.use(cookieParser());\n\n    app.use(\"/api/auth\", authRouter);\n    app.use(\"/api/user\", userRouter);\n\n    app.use(globalErrorHandler);\n\n    app.listen(PORT, async () => {\n      console.log(\"Server listening on port: \", PORT);\n    });\n  } catch (error: any) {\n    console.log(\"Failed to start server: \", error.message);\n    process.exit(1);\n  }\n};\n\nstartServer();\n","import mongoose from \"mongoose\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst DB_URI = process.env.DB_URI || \"\";\n\nexport const connectToDB = async () => {\n  try {\n    await mongoose.connect(`${DB_URI}`);\n    console.log(\"Connected to Database\");\n  } catch (error: any) {\n    console.log(\"An error occured while connecting to the database: \");\n  }\n};\n","import { Request, Response, NextFunction } from \"express\";\nimport mongoose from \"mongoose\";\n\nexport const globalErrorHandler = (\n  err: any,\n  req: Request,\n  res: Response,\n  next: NextFunction\n): any => {\n  const status: number = err.status || 500;\n  const message: string = err.message || \"Internal Server Error\";\n\n  // if (err instanceof mongoose.Error) {\n  //   console.log(\"INSTACE OOOOOOOOO\");\n  //   return res.status(400).json({\n  //     success: false,\n  //     error: message,\n  //     path: req.originalUrl,\n  //     timeStamp: new Date().toISOString(),\n  //   });\n  // }\n  console.log(`[Error]: ${status}: ${message}`);\n  return res.status(status).json({\n    success: false,\n    error: message,\n    path: req.originalUrl,\n    timeStamp: new Date().toISOString(),\n  });\n};\n\nexport class AuthError extends Error {\n  status: number;\n  constructor(message?: string, status = 401) {\n    super(message);\n    this.name = \"AuthError\";\n    this.status = status;\n    this.message = \"....UNAUTHORIZED!!!...\";\n  }\n}\n","import { Router } from \"express\";\nimport { createUser, findUser } from \"../controllers/user.controller\";\n\nconst router = Router();\n\nrouter.post(\"/\", createUser);\nrouter.get(\"/:id\", findUser);\n\nexport default router;\n","import mongoose, { Schema } from \"mongoose\";\n\nexport interface IUser {\n  firstname: string;\n  lastname: string;\n  password: string;\n  alias?: string;\n  walletAddress?: string;\n  email: string;\n  role?: \"admin\" | \"regular\";\n}\n\nconst userSchema = new Schema(\n  {\n    firstname: { type: String, required: true },\n    lastname: { type: String, required: true },\n    password: { type: String, required: true, select: false },\n    alias: { type: String },\n    walletAddress: { type: String, unique: true },\n    email: { type: String, required: true, unique: true },\n    role: { type: String, default: \"regular\", enum: [\"admin\", \"regular\"] },\n  },\n  {\n    timestamps: true,\n  }\n);\n\nexport const UserModel = mongoose.model(\"User\", userSchema);\n","import { IUser, UserModel } from \"../models/user.model\";\nimport * as bcrypt from \"bcrypt\";\n\nexport class UserService {\n  constructor(private userModel: typeof UserModel) {}\n\n  public async createUser(userDetails: IUser): Promise<IUser | any> {\n    const email = userDetails.email;\n    const isExistingUser = await this.userModel.findOne({\n      email,\n    });\n    if (isExistingUser) {\n      throw new Error(\"Email not available\");\n    }\n    let hashedPassWord;\n    if (userDetails.password) {\n      hashedPassWord = await bcrypt.hash(userDetails.password, 13);\n      userDetails.password = hashedPassWord;\n    }\n    if (userDetails.role) {\n      userDetails.role = \"regular\";\n    }\n    const user = await this.userModel.create(userDetails);\n    return user;\n  }\n\n  public async findOne(id: string): Promise<IUser | any> {\n    const user = await this.userModel.findById(id);\n\n    return user;\n  }\n\n  public async findAllUser() {\n    return await this.userModel.find({});\n  }\n}\n","import { NextFunction, Request, Response } from \"express\";\nimport { IUser, UserModel } from \"../models/user.model\";\nimport { UserService } from \"../services/user.service\";\n\nconst userService = new UserService(UserModel);\n\nexport async function createUser(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<IUser | any> {\n  try {\n    const user = await userService.createUser(req.body);\n\n    return res.status(201).json(user);\n  } catch (error) {\n    next(error);\n  }\n}\n\nexport async function findUser(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<any> {\n  try {\n    const user = await userService.findOne(req.params.id);\n\n    return res.status(200).json(user);\n  } catch (error) {\n    next(error);\n  }\n}\n","import { NextFunction, Request, Response, Router } from \"express\";\nimport { loginUser, logoutUser } from \"../controllers/auth.controller\";\nimport { authenticateJWT } from \"../middlewares/jwt-verification\";\n\nconst router = Router();\n\nrouter.post(\"/login\", loginUser);\nrouter.post(\"/logout\", authenticateJWT, logoutUser);\n\nrouter.get(\n  \"/protected\",\n  authenticateJWT,\n  (req: Request, res: Response, next: NextFunction): any => {\n    return res.status(200).json({ message: \"Welcome to the protected Route\" });\n  }\n);\n\nexport default router;\n","import jwt from \"jsonwebtoken\";\nimport { IUser, UserModel } from \"../models/user.model\";\nimport { AuthError } from \"../middlewares/error-handler\";\nimport * as bcrypt from \"bcrypt\";\nconst ACCESS_TOKEN_SECRET = process.env.JWT_ACCESS_TOKEN_SECRET as string;\nconst REFRESH_TOKEN_SECRET = process.env.JWT_REFRESH_TOKEN_SECRET as string;\n\nexport interface ILoginCredential {\n  email: string;\n  password: string;\n}\n\nexport class AuthService {\n  constructor(private userModel: typeof UserModel) {}\n  public generateAccessToken(user: IUser): string {\n    const { password, ...payload } = user;\n    return jwt.sign(payload, ACCESS_TOKEN_SECRET, { expiresIn: \"20m\" });\n  }\n\n  public generateRefreshToken(user: IUser): string {\n    const { password, ...payload } = user;\n    return jwt.sign(payload, REFRESH_TOKEN_SECRET, { expiresIn: \"10d\" });\n  }\n\n  public verifyToken(token: string, type: \"access\" | \"refresh\") {\n    const secret: any =\n      type === \"access\" ? ACCESS_TOKEN_SECRET : REFRESH_TOKEN_SECRET;\n    try {\n      const decodedUser = jwt.decode(token, secret);\n      return decodedUser;\n    } catch (error) {\n      console.log(\"Failed to verify user\", error);\n      return null;\n    }\n  }\n\n  public async loginUser(\n    userCredentials: ILoginCredential\n  ): Promise<{ accessToken: string; refreshToken: string }> {\n    const user = await this.userModel\n      .findOne<IUser>({\n        email: userCredentials.email,\n      })\n      .select(\"+password\")\n      .exec();\n    if (!user) {\n      throw new AuthError(\"User Not found\");\n    }\n\n    const isValidPassword = await bcrypt.compare(\n      userCredentials.password,\n      user.password\n    );\n    if (!isValidPassword) {\n      throw new AuthError(\"Invalid Credentials\");\n    }\n\n    const accessToken = this.generateAccessToken(user);\n    const refreshToken = this.generateRefreshToken(user);\n\n    return {\n      accessToken,\n      refreshToken,\n    };\n  }\n}\n","import { NextFunction, Request, Response } from \"express\";\nimport { AuthService, ILoginCredential } from \"../services/auth.service\";\nimport { UserModel } from \"../models/user.model\";\n\ninterface ILogoutMessage {\n  message: string;\n}\n\nconst authService = new AuthService(UserModel);\n\nexport async function loginUser(req: Request, res: Response): Promise<any> {\n  const { accessToken, refreshToken } = await authService.loginUser(req.body);\n  res.cookie(\"gibby_accessToken\", accessToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n    maxAge: 20 * 1000 * 60, // 20 minutes\n  });\n\n  res.cookie(\"gibby_refreshToken\", refreshToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n    maxAge: 10 * 1000 * 60 * 60 * 24, // 10 days\n  });\n\n  return res.status(200).json({ message: \"Login Successful\" });\n}\n\nexport function logoutUser(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): ILogoutMessage | any {\n  res.clearCookie(\"gibby_accessToken\");\n  res.clearCookie(\"gibby_refreshToken\");\n  return res\n    .status(200)\n    .json({ message: \"You are out! We hope to see you soon\" });\n}\n","import { NextFunction, Request, Response } from \"express\";\nimport { AuthError } from \"./error-handler\";\nimport { AuthService } from \"../services/auth.service\";\nimport { IUser, UserModel } from \"../models/user.model\";\nconst authService = new AuthService(UserModel);\n\n// export class MiddleWare {\n//   constructor(private authService: AuthService) {}\n//   public async authenticateJWT(\n//     req: Request,\n//     res: Response,\n//     next: NextFunction\n//   ) {\n//     try {\n//       const accessToken = req.cookies.gibby_accessToken;\n//       const refreshToken = req.cookies.gibby_refreshToken;\n\n//       if (!accessToken) {\n//         return next(new AuthError(\"....Missing Authentication Token....\"));\n//       }\n\n//       const isValidAccessToken = accessToken\n//         ? this.authService.verifyToken(accessToken, \"access\")\n//         : null; // decodes the token\n//       const isValidRefreshToken = refreshToken\n//         ? this.authService.verifyToken(refreshToken, \"refresh\")\n//         : null;\n\n//       if (!isValidAccessToken && !isValidRefreshToken) {\n//         return next(new AuthError(\"Invalid or Expired Token\"));\n//       }\n\n//       if (!isValidAccessToken && isValidRefreshToken) {\n//         const user: any = isValidRefreshToken;\n//         const newAccessToken = this.authService.generateAccessToken(user);\n//         res.cookie(\"gibby_accessToken\", newAccessToken, {\n//           httpOnly: true,\n//           secure: process.env.NODE_ENV === \"production\",\n//           sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n//           maxAge: 20 * 1000 * 60, // 20 minutes\n//         });\n//       }\n//       next();\n//     } catch (error) {\n//       console.log({ error });\n//       next(error);\n//     }\n//   }\n// }\n\nexport async function authenticateJWT(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const accessToken = req.cookies.gibby_accessToken;\n    const refreshToken = req.cookies.gibby_refreshToken;\n\n    if (!accessToken) {\n      return next(new AuthError(\"....Missing Authentication Token....\"));\n    }\n\n    const isValidAccessToken = accessToken\n      ? authService.verifyToken(accessToken, \"access\")\n      : null; // decodes the token\n    const isValidRefreshToken = refreshToken\n      ? authService.verifyToken(refreshToken, \"refresh\")\n      : null;\n\n    if (!isValidAccessToken && !isValidRefreshToken) {\n      return next(new AuthError(\"Invalid or Expired Token\"));\n    }\n\n    if (!isValidAccessToken && isValidRefreshToken) {\n      const user: any = isValidRefreshToken;\n      const newAccessToken = authService.generateAccessToken(user);\n      res.cookie(\"gibby_accessToken\", newAccessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n        maxAge: 20 * 1000 * 60, // 20 minutes\n      });\n    }\n    next();\n  } catch (error) {\n    console.log({ error });\n    next(error);\n  }\n}\n"],"mappings":"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","names":["dotenv","mongoose","Router","bcrypt","authService","router","Router","dotenv"]}