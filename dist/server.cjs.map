{"version":3,"sources":["../src/server.ts","../src/config/db.ts","../src/middlewares/error-handler.ts","../src/routes/user.route.ts","../src/models/user.model.ts","../src/services/user.service.ts","../src/controllers/user.controller.ts","../src/routes/auth.route.ts","../src/services/auth.service.ts","../src/controllers/auth.controller.ts","../src/middlewares/jwt-verification.ts","../src/routes/task.route.ts","../src/services/task.service.ts","../src/models/task.model.ts","../src/controllers/task.controller.ts"],"sourcesContent":["import express, { Request, Response } from \"express\";\nimport dotenv from \"dotenv\";\nimport morgan from \"morgan\";\nimport cookieParser from \"cookie-parser\";\nimport { connectToDB } from \"./config/db\";\nimport { globalErrorHandler } from \"./middlewares/error-handler\";\nimport userRouter from \"./routes/user.route\";\nimport authRouter from \"./routes/auth.route\";\nimport taskRouter from \"./routes/task.route\";\ndotenv.config();\n// .......................\n\nconst PORT = process.env.PORT || 7000;\n\nconst startServer = async () => {\n  try {\n    await connectToDB();\n\n    const app = express();\n\n    app.use(express.json());\n    app.use(express.urlencoded());\n    app.use(morgan(\"dev\"));\n    app.use(cookieParser());\n\n    app.use(\"/api/auth\", authRouter);\n    app.use(\"/api/user\", userRouter);\n    app.use(\"/api/task\", taskRouter);\n\n    app.use(globalErrorHandler);\n\n    app.listen(PORT, async () => {\n      console.log(\n        `(${process.env.NODE_ENV}) `,\n        \"Server listening on port: \",\n        PORT\n      );\n    });\n  } catch (error: any) {\n    console.log(\"Failed to start server: \", error.message);\n    process.exit(1);\n  }\n};\n\nstartServer();\n","import mongoose from \"mongoose\";\nimport dotenv from \"dotenv\";\ndotenv.config();\n\nconst DB_URI = process.env.DB_URI || \"\";\n\nexport const connectToDB = async () => {\n  try {\n    await mongoose.connect(`${DB_URI}`);\n    console.log(\"Connected to Database\");\n  } catch (error: any) {\n    console.log(\"An error occured while connecting to the database: \");\n  }\n};\n","import { Request, Response, NextFunction } from \"express\";\nimport mongoose from \"mongoose\";\n\nexport const globalErrorHandler = (\n  err: any,\n  req: Request,\n  res: Response,\n  next: NextFunction\n): any => {\n  const status: number = err.status || 500;\n  const message: string = err.message || \"Internal Server Error\";\n\n  // if (err instanceof mongoose.Error) {\n  //   console.log(\"INSTACE OOOOOOOOO\");\n  //   return res.status(400).json({\n  //     success: false,\n  //     error: message,\n  //     path: req.originalUrl,\n  //     timeStamp: new Date().toISOString(),\n  //   });\n  // }\n  console.log(`[Error]: ${status}: ${message}`);\n  return res.status(status).json({\n    success: false,\n    error: message,\n    path: req.originalUrl,\n    timeStamp: new Date().toISOString(),\n  });\n};\n\nexport class AuthError extends Error {\n  status: number;\n  constructor(message?: string, status = 401) {\n    super(message);\n    this.name = \"AuthError\";\n    this.status = status;\n    this.message = \"....UNAUTHORIZED!!!...\";\n  }\n}\n\nexport class APIError extends Error {\n  public status: number;\n  constructor(\n    message: string = \"Something went wrong. Please try the action again\",\n    status: number = 500\n  ) {\n    super(message);\n    this.name = \"APIError\";\n    this.status = status;\n  }\n}\n","import { Router } from \"express\";\nimport { createUser, findUser } from \"../controllers/user.controller\";\n\nconst router = Router();\n\nrouter.post(\"/\", createUser);\nrouter.get(\"/:id\", findUser);\n\nexport default router;\n","import mongoose, { Schema } from \"mongoose\";\n\nexport interface IUser {\n  firstname: string;\n  lastname: string;\n  password?: string;\n  alias?: string;\n  walletAddress?: string;\n  email: string;\n  role?: \"admin\" | \"regular\";\n  ranking:\n    | \"explorer\"\n    | \"initiate\"\n    | \"pathfinder\"\n    | \"pioneer\"\n    | \"validator\"\n    | \"guardian\"\n    | \"legend\";\n}\n\nconst userSchema = new Schema(\n  {\n    firstname: { type: String, required: true },\n    lastname: { type: String, required: true },\n    password: { type: String, required: true, select: false },\n    alias: { type: String },\n    walletAddress: { type: String, unique: true },\n    email: { type: String, required: true, unique: true },\n    ranking: {\n      type: String,\n      default: \"explorer\",\n      enum: [\n        \"explorer\",\n        \"initiate\",\n        \"pathfinder\",\n        \"pioneer\",\n        \"validator\",\n        \"guardian\",\n        \"legend\",\n      ],\n    },\n    role: { type: String, default: \"regular\", enum: [\"admin\", \"regular\"] },\n  },\n  {\n    timestamps: true,\n  }\n);\n\nexport const UserModel = mongoose.model(\"User\", userSchema);\n","import { CreateUserDto } from \"../dtos/user.dto\";\nimport { IUser, UserModel } from \"../models/user.model\";\nimport * as bcrypt from \"bcrypt\";\n\nexport class UserService {\n  constructor(private userModel: typeof UserModel) {}\n\n  public async createUser(userDetails: CreateUserDto): Promise<IUser | any> {\n    const email = userDetails.email;\n    const isExistingUser = await this.userModel.findOne({\n      email,\n    });\n    if (isExistingUser) {\n      throw new Error(\"Email not available\");\n    }\n    let hashedPassWord;\n    if (userDetails.password) {\n      hashedPassWord = await bcrypt.hash(userDetails.password, 13);\n      userDetails.password = hashedPassWord;\n    }\n    if (userDetails.role) {\n      userDetails.role = \"regular\";\n    }\n    const user = await this.userModel.create(userDetails);\n    return user;\n  }\n\n  public async findOne(id: string): Promise<IUser | any> {\n    const user = await this.userModel.findById(id);\n\n    return user;\n  }\n\n  public async findAllUser() {\n    return await this.userModel.find({});\n  }\n}\n","import { NextFunction, Request, Response } from \"express\";\nimport { IUser, UserModel } from \"../models/user.model\";\nimport { UserService } from \"../services/user.service\";\n\nconst userService = new UserService(UserModel);\n\nexport async function createUser(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<IUser | any> {\n  try {\n    const user = await userService.createUser(req.body);\n\n    return res.status(201).json(user);\n  } catch (error) {\n    next(error);\n  }\n}\n\nexport async function findUser(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<any> {\n  try {\n    const user = await userService.findOne(req.params.id);\n\n    return res.status(200).json(user);\n  } catch (error) {\n    next(error);\n  }\n}\n","import { NextFunction, Request, Response, Router } from \"express\";\nimport { loginUser, logoutUser } from \"../controllers/auth.controller\";\nimport { authenticateJWT } from \"../middlewares/jwt-verification\";\n\nconst router = Router();\n\nrouter.post(\"/login\", loginUser);\nrouter.post(\"/logout\", authenticateJWT, logoutUser);\n\nrouter.get(\n  \"/protected\",\n  authenticateJWT,\n  (req: Request, res: Response, next: NextFunction): any => {\n    return res.status(200).json({ message: \"Welcome to the protected Route\" });\n  }\n);\n\nexport default router;\n","import jwt from \"jsonwebtoken\";\nimport { IUser, UserModel } from \"../models/user.model\";\nimport { AuthError } from \"../middlewares/error-handler\";\nimport * as bcrypt from \"bcrypt\";\nconst ACCESS_TOKEN_SECRET = process.env.JWT_ACCESS_TOKEN_SECRET as string;\nconst REFRESH_TOKEN_SECRET = process.env.JWT_REFRESH_TOKEN_SECRET as string;\n\nexport interface ILoginCredential {\n  email: string;\n  password: string;\n}\n\nexport class AuthService {\n  constructor(private userModel: typeof UserModel) {}\n  public generateAccessToken(user: IUser): string {\n    return jwt.sign(user, ACCESS_TOKEN_SECRET, { expiresIn: \"20m\" });\n  }\n\n  public generateRefreshToken(user: IUser): string {\n    return jwt.sign(user, REFRESH_TOKEN_SECRET, { expiresIn: \"10d\" });\n  }\n\n  public verifyToken(token: string, type: \"access\" | \"refresh\") {\n    const secret: any =\n      type === \"access\" ? ACCESS_TOKEN_SECRET : REFRESH_TOKEN_SECRET;\n    try {\n      const decodedUser = jwt.decode(token, secret);\n      return decodedUser;\n    } catch (error) {\n      console.log(\"Failed to verify user\", error);\n      return null;\n    }\n  }\n\n  public async loginUser(\n    userCredentials: ILoginCredential\n  ): Promise<{ accessToken: string; refreshToken: string }> {\n    const user = await this.userModel\n      .findOne<IUser>({\n        email: userCredentials.email,\n      })\n      .select(\"+password\")\n      .exec();\n    if (!user) {\n      throw new AuthError(\"User Not found\");\n    }\n\n    const isValidPassword = await bcrypt.compare(\n      userCredentials.password,\n      user.password as string\n    );\n    if (!isValidPassword) {\n      throw new AuthError(\"Invalid Credentials\");\n    }\n\n    const accessToken = this.generateAccessToken(user);\n    const refreshToken = this.generateRefreshToken(user);\n\n    return {\n      accessToken,\n      refreshToken,\n    };\n  }\n}\n","import { NextFunction, Request, Response } from \"express\";\nimport { AuthService, ILoginCredential } from \"../services/auth.service\";\nimport { UserModel } from \"../models/user.model\";\n\ninterface ILogoutMessage {\n  message: string;\n}\n\nconst authService = new AuthService(UserModel);\n\nexport async function loginUser(req: Request, res: Response): Promise<any> {\n  const { accessToken, refreshToken } = await authService.loginUser(req.body);\n  res.cookie(\"gibby_accessToken\", accessToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n    maxAge: 20 * 1000 * 60, // 20 minutes\n  });\n\n  res.cookie(\"gibby_refreshToken\", refreshToken, {\n    httpOnly: true,\n    secure: process.env.NODE_ENV === \"production\",\n    sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n    maxAge: 10 * 1000 * 60 * 60 * 24, // 10 days\n  });\n\n  return res.status(200).json({ message: \"Login Successful\" });\n}\n\nexport function logoutUser(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): ILogoutMessage | any {\n  res.clearCookie(\"gibby_accessToken\");\n  res.clearCookie(\"gibby_refreshToken\");\n  return res\n    .status(200)\n    .json({ message: \"You are out! We hope to see you soon\" });\n}\n","import { NextFunction, Request, Response } from \"express\";\nimport { AuthError } from \"./error-handler\";\nimport { AuthService } from \"../services/auth.service\";\nimport { IUser, UserModel } from \"../models/user.model\";\nconst authService = new AuthService(UserModel);\n\ndeclare global {\n  namespace Express {\n    interface Request {\n      user?: IUser;\n    }\n  }\n}\n\nexport async function authenticateJWT(\n  req: Request,\n  res: Response,\n  next: NextFunction\n) {\n  try {\n    const accessToken = req.cookies.gibby_accessToken;\n    const refreshToken = req.cookies.gibby_refreshToken;\n\n    if (!accessToken && !refreshToken) {\n      return next(new AuthError(\"....Missing Authentication Token....\"));\n    }\n\n    const isValidAccessToken = accessToken\n      ? authService.verifyToken(accessToken, \"access\")\n      : null; // decodes the token\n    const isValidRefreshToken = refreshToken\n      ? authService.verifyToken(refreshToken, \"refresh\")\n      : null;\n\n    if (!isValidAccessToken && !isValidRefreshToken) {\n      return next(new AuthError(\"Invalid or Expired Token\"));\n    }\n\n    if (!isValidAccessToken && isValidRefreshToken) {\n      console.log(\"[MESSAGE]: \", \"Token Renewed_______\");\n      const userPayload: any = isValidRefreshToken;\n      const newAccessToken = authService.generateAccessToken(userPayload._doc);\n\n      req.user = userPayload._doc;\n\n      res.cookie(\"gibby_accessToken\", newAccessToken, {\n        httpOnly: true,\n        secure: process.env.NODE_ENV === \"production\",\n        sameSite: process.env.NODE_ENV === \"production\" ? \"strict\" : \"lax\",\n        maxAge: 20 * 1000 * 60, // 20 minutes\n      });\n    }\n    next();\n  } catch (error) {\n    console.log({ error });\n    next(error);\n  }\n}\n","import { Router } from \"express\";\nimport { authenticateJWT } from \"../middlewares/jwt-verification\";\nimport {\n  createTask,\n  findAllTask,\n  findSingleTask,\n} from \"../controllers/task.controller\";\n\nconst router = Router();\n\nrouter.post(\"/\", authenticateJWT, createTask);\nrouter.get(\"/\", authenticateJWT, findAllTask);\nrouter.get(\"/:id\", authenticateJWT, findSingleTask);\n\nexport default router;\n","import { CreateTaskDto, QueryTaskDto } from \"../dtos/task.dto\";\nimport { APIError } from \"../middlewares/error-handler\";\nimport { ITask, TaskModel } from \"../models/task.model\";\n\nexport class TaskService {\n  constructor(private readonly taskModel: typeof TaskModel) {}\n\n  public async createTask(taskDto: CreateTaskDto): Promise<ITask | any> {\n    console.log(taskDto);\n    const task = await this.taskModel.findOne({\n      name: taskDto.name,\n      owner: taskDto.owner,\n    });\n\n    if (task) {\n      throw new APIError(\"Task Already Exists\", 400);\n    }\n\n    const newTask = await this.taskModel.create(taskDto);\n    return newTask;\n  }\n\n  /**\n   * Returns all tasks based on the query parameters\n   * @param taskDto\n   * @returns {tasks, nestCursor: string}\n   */\n  public async fetchUserTasks(taskDto: QueryTaskDto) {\n    let { limit, cursor, ...others } = taskDto;\n    if (!limit) {\n      limit = 20;\n    }\n\n    const query: any = { others };\n    if (cursor) {\n      query._id = { $lt: cursor };\n    }\n\n    const tasks = await this.taskModel\n      .find(query)\n      .sort({ _id: -1 })\n      .limit(limit + 1);\n\n    const hasNextPage = tasks.length > limit;\n    const nextCursor = hasNextPage ? tasks[limit]._id : null;\n    return {\n      tasks,\n      nextCursor,\n    };\n  }\n\n  public async fetchSingleTask(id: string) {\n    const task = await this.taskModel.findById(id);\n    return task;\n  }\n}\n","import mongoose, { Schema } from \"mongoose\";\n\nexport interface ITask {\n  name: string;\n  description?: string;\n  category?: string;\n  tags?: string;\n  owner: any;\n  isStillOpen: boolean;\n  source: string;\n  closeDate: string;\n  workStatus: \"initialised\" | \"completed\";\n  createdAt: string;\n  updatedAt: string;\n}\n\nconst TaskSchema = new Schema(\n  {\n    name: { type: String, required: true, trim: true, maxlength: 255 },\n    description: { type: String, trim: true },\n    category: { type: String, trim: true },\n    tags: [{ type: String, trim: true }],\n    tools: [{ type: String, trim: true }],\n    owner: {\n      type: Schema.Types.ObjectId,\n      ref: \"User\",\n      required: true,\n      trim: true,\n    },\n    isStillOpen: { type: Boolean, default: true },\n    source: { type: String },\n    closeDate: { type: Date },\n    workStatus: {\n      type: String,\n      enum: [\"initialised\", \"completed\"],\n      default: \"initialised\",\n    },\n  },\n  {\n    timestamps: true,\n  }\n);\n\nexport const TaskModel = mongoose.model(\"Task\", TaskSchema);\n","import { NextFunction, Request, Response } from \"express\";\n\nimport { TaskService } from \"../services/task.service\";\n\nimport { ITask, TaskModel } from \"../models/task.model\";\nconst taskService = new TaskService(TaskModel);\n\nexport async function createTask(\n  req: any,\n  res: Response,\n  next: NextFunction\n): Promise<ITask | any> {\n  try {\n    const taskObj = req.body;\n    console.log(\"user: \", req.user);\n    taskObj.owner = req.user._id;\n    const newTask = await taskService.createTask(req.body);\n    return res.status(201).json(newTask);\n  } catch (error) {\n    next(error);\n  }\n}\n\nexport async function findSingleTask(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<ITask | any> {\n  try {\n    const task = await taskService.fetchSingleTask(req.params.id);\n    return res.status(200).json(task);\n  } catch (error) {\n    next(error);\n  }\n}\n\nexport async function findAllTask(\n  req: Request,\n  res: Response,\n  next: NextFunction\n): Promise<ITask[] | any> {\n  try {\n    const task = await taskService.fetchUserTasks(req.query);\n    return res.status(200).json(task);\n  } catch (error) {\n    next(error);\n  }\n}\n"],"mappings":"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","names":["import_express","import_dotenv","dotenv","mongoose","import_mongoose","mongoose","import_express","bcrypt","jwt","authService","router","import_express","import_mongoose","mongoose","router","dotenv","express","morgan","cookieParser"]}